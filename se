#!/bin/bash
# Launch Indras Workspace instances.
#
# Usage:
#   ./se                    Launch single instance (normal onboarding)
#   ./se Love Joy           Launch two instances (keep existing data)
#   ./se Love Joy --clean   Launch two instances with fresh data
#   ./se --clean            Launch single instance with fresh data
#   ./se --chat             Launch indras-chat instead of indras-workspace
#   ./se Love Joy --chat    Launch two chat instances
#
# Each named instance gets its own data directory under /tmp/indras-<name>.
# Windows are named per identity and tiled across the screen.

set -e

# Log file for diagnostics
LOGFILE="$(cd "$(dirname "$0")" && pwd)/LOGS.jsonl"

# Parse args: separate names from flags
CLEAN=""
SEED_SCRIPT=""
APP="indras-workspace"
NAMES=()
for arg in "$@"; do
  if [ "$arg" = "--clean" ]; then
    CLEAN="--clean"
  elif [ "$arg" = "--chat" ]; then
    APP="indras-chat"
  elif [ "$arg" = "--mock" ]; then
    SEED_SCRIPT="--seed-script=crates/indras-workspace/scripts/scenarios/mock_artifacts.lua"
  elif [ "$arg" = "--remock" ]; then
    CLEAN="--clean"
    SEED_SCRIPT="--seed-script=crates/indras-workspace/scripts/scenarios/fresh_mock.lua"
  elif [[ "$arg" == --seed-script=* ]]; then
    SEED_SCRIPT="$arg"
  else
    NAMES+=("$arg")
  fi
done

# Enable lua-scripting feature when a seed script is requested
FEATURES=""
if [ -n "$SEED_SCRIPT" ]; then
  FEATURES="--features lua-scripting"
fi

if [ ${#NAMES[@]} -eq 0 ]; then
  # No names: single instance, normal flow
  echo "Launching $APP"
  echo "Logging stdout to $LOGFILE"
  cargo run -p "$APP" $FEATURES -- $CLEAN $SEED_SCRIPT 2>&1 | tee -a "$LOGFILE"
  exit 0
fi

# Build once before launching instances
cargo build -p "$APP" $FEATURES

PIDS=()
NUM=${#NAMES[@]}

# Get screen dimensions for tiling
SCREEN_BOUNDS=$(osascript -e 'tell application "Finder" to get bounds of window of desktop')
SCREEN_W=$(echo "$SCREEN_BOUNDS" | awk -F', ' '{print $3}')
SCREEN_H=$(echo "$SCREEN_BOUNDS" | awk -F', ' '{print $4}')
TILE_W=$((SCREEN_W / NUM))
TILE_H=$((SCREEN_H - 25)) # leave room for menu bar

echo "Screen: ${SCREEN_W}x${SCREEN_H}, tiling $NUM windows at ${TILE_W}x${TILE_H}"
[ -n "$CLEAN" ] && echo "Clean mode: wiping data directories"

# Clean mesh coordination directory when starting fresh
[ -n "$CLEAN" ] && rm -rf /tmp/indras-mesh

# Build comma-separated peer list for Lua mesh scripts
PEERS_LIST=$(IFS=,; echo "${NAMES[*]}")

IDX=0
for NAME in "${NAMES[@]}"; do
  LOWER_NAME=$(echo "$NAME" | tr '[:upper:]' '[:lower:]')
  DATA_DIR="/tmp/indras-${LOWER_NAME}"
  WIN_X=$((IDX * TILE_W))
  echo "Launching $NAME at x=$WIN_X (data: $DATA_DIR)"
  INDRAS_NAME="$NAME" INDRAS_DATA_DIR="$DATA_DIR" \
    INDRAS_PEERS="$PEERS_LIST" \
    INDRAS_WIN_X="$WIN_X" INDRAS_WIN_Y=25 \
    INDRAS_WIN_W="$TILE_W" INDRAS_WIN_H="$TILE_H" \
    cargo run -p "$APP" $FEATURES -- $CLEAN $SEED_SCRIPT 2>&1 | tee -a "$LOGFILE" &
  PIDS+=($!)
  IDX=$((IDX + 1))
  sleep 0.5 # stagger window creation
done

echo ""
echo "Running: ${NAMES[*]}${CLEAN:+ (clean)}"
echo "PIDs: ${PIDS[*]}"
echo "Press Ctrl+C to stop all instances."

# Bring all indras-workspace windows to front after they finish rendering
bring_windows_to_front() {
    osascript -e '
        tell application "System Events"
            set appProcs to every process whose name is "indras-workspace" or name is "indras-chat"
            if (count of appProcs) > 0 then
                repeat with proc in appProcs
                    set frontmost of proc to true
                end repeat
            else
                set allProcs to every process whose visible is true
                repeat with proc in allProcs
                    try
                        set wins to every window of proc whose name contains "Indras"
                        if (count of wins) > 0 then
                            set frontmost of proc to true
                        end if
                    end try
                end repeat
            end if
        end tell
    '
}

# Wait for windows to finish creating, then bring them all to front
(
    sleep 3
    bring_windows_to_front
) &

# Clean up on exit and consolidate world views
cleanup_and_consolidate() {
  kill "${PIDS[@]}" 2>/dev/null
  # Give instances a moment to write their world-view.json on shutdown
  sleep 2
  consolidate_world_views
  exit
}

consolidate_world_views() {
  local OUTPUT="./WORLD_VIEW.json"
  local FOUND=0

  # Build a JSON object: { "timestamp": "...", "instances": { "Name": {...}, ... } }
  local INSTANCES="{"
  local FIRST=true

  for NAME in "${NAMES[@]}"; do
    LOWER_NAME=$(echo "$NAME" | tr '[:upper:]' '[:lower:]')
    WV="/tmp/indras-${LOWER_NAME}/world-view.json"
    if [ -f "$WV" ]; then
      FOUND=$((FOUND + 1))
      if [ "$FIRST" = true ]; then
        FIRST=false
      else
        INSTANCES+=","
      fi
      INSTANCES+="\"$NAME\":$(cat "$WV")"
    else
      echo "  Warning: no world-view.json for $NAME ($WV)"
    fi
  done
  INSTANCES+="}"

  if [ $FOUND -eq 0 ]; then
    echo "No world-view files found to consolidate."
    return
  fi

  # Wrap in top-level object with timestamp
  local NOW
  NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  printf '{\n  "consolidated_at": "%s",\n  "instance_count": %d,\n  "instances": %s\n}\n' \
    "$NOW" "$FOUND" "$INSTANCES" >"$OUTPUT"

  # Pretty-print if python3 is available
  if command -v python3 &>/dev/null; then
    python3 -m json.tool "$OUTPUT" >"${OUTPUT}.tmp" 2>/dev/null && mv "${OUTPUT}.tmp" "$OUTPUT"
  fi

  echo ""
  echo "Consolidated $FOUND world view(s) â†’ $OUTPUT"
}

trap cleanup_and_consolidate INT TERM
wait
consolidate_world_views
