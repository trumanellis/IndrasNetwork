{
  "created_at": "2026-02-17T13:37:57.357Z",
  "trigger": "auto",
  "active_modes": {
    "ecomode": {
      "original_prompt": "<task-notification>\n<task-id>af83f45</task-id>\n<status>completed</status>\n<summary>Agent \"Explore indras-sync crate\" completed</summary>\n<result>Now I have everything needed. Here is the complete structured summary for the `AGENTS.md` file.\n\n---\n\n## `crates/indras-sync` — Complete Summary\n\n### 1. Source Files\n\n| File | Contents |\n|---|---|\n| `src/lib.rs` | Crate root. Module declarations and re-exports. Contains the crate-level doc comment explaining the dual sync strategy with a runnable example. |\n| `src/document.rs` | `InterfaceDocument` — Automerge `AutoCommit`-backed document for N-peer interfaces. Stores members (Map), metadata (Map), and events (List of postcard-serialized bytes). Has `generate_sync_message` / `receive_sync_message` using Automerge's built-in sync protocol, plus `apply_update` (full merge) and `get_heads`. |\n| `src/artifact_document.rs` | `ArtifactDocument` — Automerge `AutoCommit`-backed document for artifact trees. Schema: `artifact_id`, `steward`, `artifact_type`, `status`, `created_at`, `references` (List of Maps), `grants` (List of Maps), `metadata` (Map of Bytes). Exposes `save_after` / `load_incremental` for incremental delta sync. Contains the `CRITICAL: Never cache ObjIds` comment in both ObjId helper blocks. |\n| `src/head_tracker.rs` | `HeadTracker` — Pure data structure, no Automerge doc. Maps `(ArtifactId, PlayerId)` → `Vec<ChangeHash>`. Absent entry = full sync needed. Serializable via postcard. Methods: `update`, `get`, `remove_peer`, `remove_artifact`, `save`, `load`. |\n| `src/raw_sync.rs` | `RawSync` — Stateless struct with three class-level functions: `prepare_payload`, `apply_payload`, `broadcast_payloads`. Produces and consumes `ArtifactSyncPayload`. This is the `save_after → transport → load_incremental` pattern. |\n| `src/event_store.rs` | `EventStore<I>` — Store-and-forward event log. Tracks which events are pending per peer (by index into append-only `Vec`). Supports `append`, `pending_for`, `mark_delivered`, `prune_delivered`, `since`. New members get all existing events queued as pending. |\n| `src/sync_protocol.rs` | `SyncProtocol` (stateless), `SyncState<I>`, `PeerSyncState`, `PendingDelivery`. Wraps Automerge's per-peer `sync::State` in `PeerSyncState` with `awaiting_response` / `rounds` bookkeeping. `SyncProtocol::handle_sync_message` is the responder-side convenience combinator. |\n| `src/n_interface.rs` | `NInterface<I>` — The top-level integration struct. Combines `InterfaceDocument` (in `RwLock`), `EventStore<I>`, and `SyncState<I>`. Implements the `NInterfaceTrait<I>` from `indras-core` via `#[async_trait]`. Has `sync_members()` for re-syncing the local members `HashSet` from the Automerge doc after an external merge. |\n| `src/error.rs` | `SyncError` enum with 9 variants; `SyncResult<T>` type alias. |\n\n---\n\n### 2. Dual Sync Strategy\n\n**`InterfaceDocument` — N-peer interfaces (members, metadata, events)**\n\n- Uses Automerge's full built-in sync protocol (`generate_sync_message` / `receive_sync_message`) with per-peer `sync::State` objects managed by `SyncState<I>`.\n- Also supports a simpler `apply_update` path (save full doc bytes, merge) used by `NInterface::merge_sync` / `generate_sync`.\n- Events are postcard-serialized and stored as `ScalarValue::Bytes` in an Automerge List. This means event ordering is CRDT-convergent but append-only.\n- The `EventStore<I>` layer sits alongside (not inside) the Automerge doc — it tracks delivery confirmation so offline peers accumulate their pending events separately.\n\n**`ArtifactDocument` — Artifact trees (metadata, refs, grants)**\n\n- Uses the `save_after` / `load_incremental` incremental delta pattern, coordinated by `HeadTracker` and `RawSync`.\n- No per-peer Automerge `sync::State`; instead, `HeadTracker` records what each peer last received (their `ChangeHash` vector), and `save_after(known_heads)` produces the minimal delta.\n- An unknown peer (empty `get()` result from `HeadTracker`) triggers a full export — this is the \"stale = over-send\" semantics.\n\n---\n\n### 3. `HeadTracker` — Per-Peer Head Tracking\n\n```rust\npub struct HeadTracker {\n    heads: HashMap<(ArtifactId, PlayerId), Vec<ChangeHash>>,\n}\n```\n\n- **Absent entry → full sync.** `get()` returns `&[]` for unknown `(artifact, peer)` pairs. `ArtifactDocument::save_after(&[])` exports the entire document.\n- **Present entry → incremental sync.** `get()` returns the heads the peer already has; `save_after(those_heads)` exports only what changed since.\n- **After applying a payload**, `tracker.update(artifact_id, sender, sender_heads)` records the sender's current heads. On the next sync cycle, only the new delta is sent.\n- **Stale = over-send.** If a peer's entry is stale (tracker was not updated after a failed delivery), `save_after` will include changes the peer already has. Automerge's `load_incremental` is idempotent, so duplicates are silently ignored.\n- Serializable to/from postcard bytes via `save()` / `load()`.\n\n---\n\n### 4. `RawSync` — The `prepare_payload → transport → apply_payload` Pattern\n\n```rust\n// Sender side\nlet payload = RawSync::prepare_payload(&mut doc, &tracker, &artifact_id, &recipient);\n// -- transport payload over the wire --\n\n// Receiver side\nRawSync::apply_payload(&mut doc, &mut tracker, payload, &sender)?;\n```\n\n`prepare_payload`:\n1. Calls `tracker.get(artifact_id, recipient)` to get known heads (empty → full export).\n2. Calls `doc.save_after(known_heads)` to produce the delta bytes.\n3. Captures `doc.get_heads()` as `sender_heads` and packages into `ArtifactSyncPayload`.\n\n`apply_payload`:\n1. If `payload.changes` is non-empty, calls `doc.load_incremental(&payload.changes)`.\n2. Calls `tracker.update(&payload.artifact_id, sender, sender_heads)` to advance the sender's known position.\n\n`broadcast_payloads`: Calls `prepare_payload` for each member of `audience` except `self_id`, returning `Vec<(PlayerId, ArtifactSyncPayload)>`.\n\n**Wire type:**\n```rust\npub struct ArtifactSyncPayload {\n    pub artifact_id: ArtifactId,\n    pub sender_heads: Vec<[u8; 32]>,  // raw ChangeHash bytes\n    pub changes: Vec<u8>,              // from save_after; may be empty\n}\n```\n\n---\n\n### 5. Key Public Types and Traits\n\n| Symbol | Kind | Where |\n|---|---|---|\n| `InterfaceDocument` | struct | `document.rs` |\n| `ArtifactDocument` | struct | `artifact_document.rs` |\n| `EventStore<I>` | struct | `event_store.rs` |\n| `HeadTracker` | struct | `head_tracker.rs` |\n| `RawSync` | struct (stateless) | `raw_sync.rs` |\n| `ArtifactSyncPayload` | struct (Serialize/Deserialize) | `raw_sync.rs` |\n| `NInterface<I>` | struct | `n_interface.rs` |\n| `SyncProtocol` | struct (stateless) | `sync_protocol.rs` |\n| `SyncState<I>` | struct | `sync_protocol.rs` |\n| `PeerSyncState` | struct | `sync_protocol.rs` |\n| `PendingDelivery` | struct (Serialize/Deserialize) | `sync_protocol.rs` |\n| `SyncError` | enum (thiserror) | `error.rs` |\n| `SyncResult<T>` | type alias | `error.rs` |\n\n`NInterface<I>` implements `NInterfaceTrait<I>` from `indras-core` (async, requires `I: PeerIdentity + Serialize + Deserialize`).\n\n`InterfaceDocument` exposes both Automerge sync-protocol methods and the simpler `apply_update` / `merge` methods. `ArtifactDocument` only exposes `save_after` / `load_incremental` (no per-peer sync state).\n\n`PeerSyncState` cannot be `Clone`d meaningfully — the `Clone` impl creates a fresh `automerge::sync::State` (the original state is not copyable). This is noted inline.\n\n---\n\n### 6. Workspace Dependencies\n\n**From `Cargo.toml`:**\n\n| Dep | Purpose |\n|---|---|\n| `indras-core` | `PeerIdentity`, `InterfaceEvent`, `InterfaceId`, `SyncMessage`, `NInterfaceTrait`, `InterfaceMetadata`, `EventId`, `InterfaceError` |\n| `indras-transport` | Listed as dep (imported but `NInterface` plumbs transport externally) |\n| `indras-gossip` | Listed as dep (topic derivation via `TopicId::from_interface`) |\n| `indras-artifacts` | `ArtifactId`, `PlayerId`, `ArtifactRef`, `AccessGrant`, `AccessMode`, `ArtifactStatus`, `TreeType` |\n| `automerge` | CRDT engine: `AutoCommit`, `sync::State`, `ChangeHash`, `ObjId`, `ObjType`, etc. |\n| `serde` + `postcard` | Serialization for events in the doc, `HeadTracker`, `ArtifactSyncPayload` |\n| `hex` | Encoding binary IDs as Automerge string keys |\n| `tokio` + `async-trait` | Async trait impl for `NInterfaceTrait` |\n| `thiserror` | `SyncError` |\n| `tracing` | `#[instrument]` on `SyncProtocol` methods |\n| `dashmap` | Listed as dep (not directly visible in src, likely used by consumers) |\n| `chrono` | Used for `InterfaceMetadata::created_at` timestamp |\n\n**Who depends on `indras-sync`:**\n- `indras-network` (workspace dep)\n- `indras-node` (workspace dep)\n- `indras-sync-engine` depends on it transitively (it has its own crate)\n\n---\n\n### 7. Gotchas\n\n**Never cache Automerge `ObjId`s.**\nBoth `InterfaceDocument` and `ArtifactDocument` re-fetch their sub-object IDs (`members_obj()`, `events_obj()`, `references_obj()`, etc.) on every access via `doc.get(ROOT, key)`. This is explicitly called out with the comment `CRITICAL: Never cache ObjIds — they go stale after sync/merge.` Stale ObjIds silently return wrong data or panic after a merge operation changes the internal Automerge document structure.\n\n**`ArtifactDocument::empty()` for bootstrapping receivers.**\nWhen a peer receives its first `ArtifactSyncPayload` for an artifact it has never seen, it must start with `ArtifactDocument::empty()` (not `ArtifactDocument::new(...)`). `new()` pre-initializes the schema (writes `artifact_id`, `steward`, `references` List, etc.) which would conflict with the incoming changes. `empty()` is a bare `AutoCommit::new()` with no schema — it becomes fully initialized by `load_incremental(payload.changes)`.\n\n**`InterfaceDocument` requires both sides to share a common Automerge root.**\nThe Automerge sync protocol only merges cleanly when both documents share the same initial root objects. If doc A was created with `InterfaceDocument::new()` and doc B was also created independently with `InterfaceDocument::new()`, they will each have distinct ObjIds for `members`, `events`, etc. — they will not merge correctly. The correct pattern (demonstrated in tests) is to create one document, then `fork()` it, so both share the same initial commit.\n\n**`apply_update` vs. sync protocol: two different patterns for `InterfaceDocument`.**\n`NInterface::generate_sync` / `merge_sync` use the simpler `save()` + `apply_update()` (full doc bytes, single round). `SyncProtocol::generate_sync_message` / `receive_sync_message` use the efficient multi-round Automerge protocol with per-peer `sync::State`. Do not mix them for the same peer session — the `sync::State` will desync.\n\n**`PeerSyncState::clone()` resets the Automerge sync state.**\nThe `Clone` impl deliberately creates a fresh `automerge::sync::State` because the real state is not cloneable. Cloning a `PeerSyncState` means the cloned copy will reconverge from scratch on next use. Do not rely on clones for active sync sessions.\n\n**`EventStore` pruning requires all members to have delivery tracking.**\n`prune_delivered()` computes `min(delivered.sequence)` across all current members. Members that have never had `mark_delivered` called (e.g. the local sender, who never receives their own events) are excluded from the min calculation. This means senders' events will not block pruning, but newly added members with no delivery record will also not block it — check your prune call sites when adding late-joining peers.\n\n**`sync_members()` must be called after external merges on `NInterface`.**\n`NInterface` maintains a local `HashSet<I> members` field that is the source of truth for `NInterfaceTrait::members()`. After `merge_sync()` (which modifies the Automerge document), `sync_members()` is called automatically. But if you call `document_mut()` directly and add/remove members, you must call `sync_members()` manually to propagate those changes to the `EventStore` and the local set.</result>\n<usage>total_tokens: 81809\ntool_uses: 14\nduration_ms: 88675</usage>\n</task-notification>\nFull transcript available at: /private/tmp/claude-501/-Users-truman-Code-IndrasNetwork/tasks/af83f45.output"
    }
  },
  "todo_summary": {
    "pending": 0,
    "in_progress": 0,
    "completed": 0
  },
  "wisdom_exported": false
}