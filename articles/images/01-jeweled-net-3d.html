<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>The Jeweled Net â€” 3D</title>
<style>
  body { margin: 0; overflow: hidden; background: #010208; }
  canvas { display: block; }
</style>
</head>
<body>
<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/" } }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x010208);
scene.fog = new THREE.FogExp2(0x040818, 0.025);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
camera.position.set(0, 4, 14);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.8;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.35;

// Heavy bloom for ethereal glow
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 2.2, 0.6, 0.05);
composer.addPass(bloom);

const palette = [
  new THREE.Color(0xd4a843),
  new THREE.Color(0x4390d4),
  new THREE.Color(0x43b4a0),
  new THREE.Color(0xa070d0),
];

// Generate lattice nodes
const nodes = [];
const nodeGroup = new THREE.Group();
const span = 5;
const spacing = 2.5;

for (let x = -span; x <= span; x += spacing) {
  for (let y = -span; y <= span; y += spacing) {
    for (let z = -span; z <= span; z += spacing) {
      const jx = x + (Math.random() - 0.5) * 0.8;
      const jy = y + (Math.random() - 0.5) * 0.8;
      const jz = z + (Math.random() - 0.5) * 0.8;
      const dist = Math.sqrt(jx*jx + jy*jy + jz*jz);
      if (dist > span + 1) continue;

      const col = palette[Math.floor(Math.random() * palette.length)];
      const size = 0.1 + Math.random() * 0.16;
      const intensity = Math.max(0.4, 1 - dist / (span + 1));

      // Glowing jewel core
      const geo = new THREE.SphereGeometry(size, 16, 16);
      const mat = new THREE.MeshStandardMaterial({
        color: col,
        emissive: col,
        emissiveIntensity: 3.0 * intensity,
        roughness: 0.1,
        metalness: 0.9,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(jx, jy, jz);
      mesh.userData = { baseIntensity: 3.0 * intensity, phase: Math.random() * Math.PI * 2, col };

      // Ethereal halo around each jewel
      const haloGeo = new THREE.SphereGeometry(size * 4, 16, 16);
      const haloMat = new THREE.MeshBasicMaterial({
        color: col,
        transparent: true,
        opacity: 0.04 * intensity,
        depthWrite: false,
      });
      const halo = new THREE.Mesh(haloGeo, haloMat);
      mesh.add(halo);

      nodeGroup.add(mesh);
      nodes.push(mesh);
    }
  }
}
scene.add(nodeGroup);

// Glowing tube connections instead of lines
const maxDist = 3.5;
const threads = [];
for (let i = 0; i < nodes.length; i++) {
  for (let j = i + 1; j < nodes.length; j++) {
    const d = nodes[i].position.distanceTo(nodes[j].position);
    if (d < maxDist) {
      const mid = new THREE.Vector3().lerpVectors(nodes[i].position, nodes[j].position, 0.5);
      mid.x += (Math.random() - 0.5) * 0.3;
      mid.y += (Math.random() - 0.5) * 0.3;
      mid.z += (Math.random() - 0.5) * 0.3;
      const curve = new THREE.QuadraticBezierCurve3(nodes[i].position, mid, nodes[j].position);
      const proximity = 1 - d / maxDist;
      const tubeGeo = new THREE.TubeGeometry(curve, 12, 0.012 + proximity * 0.015, 6, false);
      const tubeMat = new THREE.MeshBasicMaterial({
        color: 0x004943,
        transparent: true,
        opacity: 0.11,
      });
      const tube = new THREE.Mesh(tubeGeo, tubeMat);
      tube.userData = { baseOpacity: 0.33, phase: Math.random() * Math.PI * 2 };
      scene.add(tube);
      threads.push(tube);
    }
  }
}

// Traveling light particles along threads
const travelers = [];
for (let i = 0; i < 50; i++) {
  const a = Math.floor(Math.random() * nodes.length);
  let b = Math.floor(Math.random() * nodes.length);
  if (a === b) b = (b + 1) % nodes.length;
  if (nodes[a].position.distanceTo(nodes[b].position) > maxDist) continue;
  const mid = new THREE.Vector3().lerpVectors(nodes[a].position, nodes[b].position, 0.5);
  mid.x += (Math.random() - 0.5) * 0.3;
  mid.y += (Math.random() - 0.5) * 0.3;
  mid.z += (Math.random() - 0.5) * 0.3;
  const curve = new THREE.QuadraticBezierCurve3(nodes[a].position, mid, nodes[b].position);
  const dot = new THREE.Mesh(
    new THREE.SphereGeometry(0.04, 8, 8),
    new THREE.MeshBasicMaterial({ color: 0x80ffee, transparent: true, opacity: 0.9 })
  );
  scene.add(dot);
  travelers.push({ mesh: dot, curve, speed: 0.06 + Math.random() * 0.12, offset: Math.random() });
}

// Starfield
const starGeo = new THREE.BufferGeometry();
const starVerts = [];
for (let i = 0; i < 2000; i++) {
  const r = 40 + Math.random() * 60;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  starVerts.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xaaccff, size: 0.1, transparent: true, opacity: 0.5 })));

// Ethereal ambient nebula glow
for (let i = 0; i < 6; i++) {
  const nebula = new THREE.Mesh(
    new THREE.SphereGeometry(3 + Math.random() * 3, 16, 16),
    new THREE.MeshBasicMaterial({
      color: palette[i % palette.length],
      transparent: true,
      opacity: 0.012,
      depthWrite: false,
    })
  );
  nebula.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
  scene.add(nebula);
}

// Lights
scene.add(new THREE.AmbientLight(0x2a2a4a, 0.6));
const point = new THREE.PointLight(0x00ffee, 1.5, 25);
point.position.set(0, 0, 0);
scene.add(point);
const point2 = new THREE.PointLight(0xd4a843, 0.8, 20);
point2.position.set(3, 3, 3);
scene.add(point2);

const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  controls.update();

  // Pulse nodes
  nodes.forEach(n => {
    const pulse = Math.sin(t * 0.8 + n.userData.phase) * 0.4 + 1;
    n.material.emissiveIntensity = n.userData.baseIntensity * pulse;
  });

  // Breathe threads
  threads.forEach(th => {
    th.material.opacity = th.userData.baseOpacity * (0.7 + Math.sin(t * 0.6 + th.userData.phase) * 0.3);
  });

  // Travelers
  travelers.forEach(tr => {
    const tt = (t * tr.speed + tr.offset) % 1;
    tr.mesh.position.copy(tr.curve.getPoint(tt));
    tr.mesh.material.opacity = Math.sin(tt * Math.PI) * 0.9;
  });

  point.intensity = 1.2 + Math.sin(t * 0.4) * 0.5;
  composer.render();
}
animate();

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
