<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>The Relay — 3D</title>
<style>
  body { margin: 0; overflow: hidden; background: #030210; }
  canvas { display: block; }
</style>
</head>
<body>
<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/" } }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x030210);
scene.fog = new THREE.FogExp2(0x060318, 0.03);

const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 3, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.6;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 1, 0);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 2.0, 0.5, 0.08));

// Ethereal floor -- reflective, glowing edges
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(40, 40),
  new THREE.MeshStandardMaterial({ color: 0x050218, roughness: 0.7, metalness: 0.3, emissive: 0x0a0520, emissiveIntensity: 0.3 })
);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -0.5;
scene.add(floor);

// Ground glow circles
[{ x: -4, c: 0xd4a843 }, { x: 0, c: 0x43b4a0 }, { x: 4, c: 0x4390d4 }].forEach(({ x, c }) => {
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(0.8, 1.4, 48),
    new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.08, side: THREE.DoubleSide })
  );
  ring.rotation.x = -Math.PI / 2;
  ring.position.set(x, -0.48, 0);
  scene.add(ring);
  // Haze
  const haze = new THREE.Mesh(
    new THREE.SphereGeometry(2, 16, 16),
    new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.02, depthWrite: false })
  );
  haze.position.set(x, 0.5, 0);
  scene.add(haze);
});

// Phone builder
function makePhone(color, emissiveColor, screenOn, posX) {
  const group = new THREE.Group();
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.9, 1.7, 0.1),
    new THREE.MeshStandardMaterial({
      color: 0x1a1a28,
      roughness: 0.4,
      metalness: 0.6,
      emissive: emissiveColor,
      emissiveIntensity: screenOn ? 0.15 : 0,
    })
  );
  body.position.y = 1;
  group.add(body);

  const screenMat = new THREE.MeshStandardMaterial({
    color: screenOn ? color : 0x030308,
    emissive: screenOn ? emissiveColor : 0x000000,
    emissiveIntensity: screenOn ? 1.5 : 0,
    roughness: 0.2,
  });
  const screen = new THREE.Mesh(new THREE.BoxGeometry(0.76, 1.4, 0.02), screenMat);
  screen.position.set(0, 1, 0.06);
  group.add(screen);

  if (screenOn) {
    const glow = new THREE.PointLight(emissiveColor, 1.5, 6);
    glow.position.set(0, 1, 1);
    group.add(glow);
    // Screen halo
    const halo = new THREE.Mesh(
      new THREE.PlaneGeometry(1.2, 1.8),
      new THREE.MeshBasicMaterial({ color: emissiveColor, transparent: true, opacity: 0.06, side: THREE.DoubleSide, depthWrite: false })
    );
    halo.position.set(0, 1, 0.15);
    group.add(halo);
  }

  group.position.x = posX;
  group.userData = { screen: screenMat, screenOn };
  return group;
}

const zara = makePhone(0x3a2a10, 0xd4a843, true, -4);
const kai = makePhone(0x0a2a20, 0x43b4a0, true, 0);
const isla = makePhone(0x050508, 0x4390d4, false, 4);
scene.add(zara, kai, isla);

// Envelope -- glowing, ethereal
const envGroup = new THREE.Group();
const envBody = new THREE.Mesh(
  new THREE.BoxGeometry(1.0, 0.05, 0.7),
  new THREE.MeshStandardMaterial({ color: 0xd4a843, emissive: 0xffe8a0, emissiveIntensity: 2.5, roughness: 0.3, metalness: 0.4 })
);
envGroup.add(envBody);

const flapShape = new THREE.Shape();
flapShape.moveTo(-0.5, 0); flapShape.lineTo(0, 0.35); flapShape.lineTo(0.5, 0); flapShape.closePath();
const flap = new THREE.Mesh(
  new THREE.ShapeGeometry(flapShape),
  new THREE.MeshStandardMaterial({ color: 0xffe8a0, emissive: 0xffe8a0, emissiveIntensity: 1.5, side: THREE.DoubleSide })
);
flap.rotation.x = -Math.PI / 2;
flap.position.set(0, 0.026, -0.35);
envGroup.add(flap);

// Wax seal glow
const seal = new THREE.Mesh(
  new THREE.CylinderGeometry(0.12, 0.12, 0.04, 24),
  new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff2222, emissiveIntensity: 3, roughness: 0.2 })
);
seal.position.set(0, 0.04, 0.05);
envGroup.add(seal);

// Envelope ethereal halo
const envHalo = new THREE.Mesh(
  new THREE.SphereGeometry(1.2, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xffe8a0, transparent: true, opacity: 0.03, depthWrite: false })
);
envGroup.add(envHalo);

envGroup.position.set(-1.5, 2.2, 1);
scene.add(envGroup);

const envLight = new THREE.PointLight(0xffe8a0, 2, 8);
envLight.position.copy(envGroup.position);
scene.add(envLight);

// Glowing arc trail: Zara → envelope → Kai
function makeGlowTrail(start, end, color, count) {
  const group = new THREE.Group();
  for (let i = 0; i < count; i++) {
    const t = i / count;
    const x = start.x + (end.x - start.x) * t;
    const y = start.y + (end.y - start.y) * t + Math.sin(t * Math.PI) * 1.5;
    const z = start.z + (end.z - start.z) * t + (Math.random() - 0.5) * 0.15;
    const dot = new THREE.Mesh(
      new THREE.SphereGeometry(0.03 + Math.sin(t * Math.PI) * 0.02, 8, 8),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 + Math.sin(t * Math.PI) * 0.4 })
    );
    dot.position.set(x, y, z);
    group.add(dot);
  }
  return group;
}
scene.add(makeGlowTrail(new THREE.Vector3(-4, 1.5, 0.5), new THREE.Vector3(-1.5, 2.2, 1), 0xd4a843, 40));

// Dormant trail to Isla (ethereal wisps)
const dormant = makeGlowTrail(new THREE.Vector3(0, 1.5, 0.5), new THREE.Vector3(4, 1.5, 0), 0x4390d4, 25);
dormant.children.forEach(c => { c.material.opacity *= 0.15; });
scene.add(dormant);

// Labels as small glowing sprites
['Zara', 'Kai', 'Isla'].forEach((name, i) => {
  const canvas = document.createElement('canvas');
  canvas.width = 128; canvas.height = 48;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = ['#d4a843', '#43b4a0', '#4390d4'][i];
  ctx.font = '24px Georgia';
  ctx.textAlign = 'center';
  ctx.fillText(name, 64, 32);
  const tex = new THREE.CanvasTexture(canvas);
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.6 }));
  sprite.position.set([-4, 0, 4][i], -0.1, 1.5);
  sprite.scale.set(1.2, 0.45, 1);
  scene.add(sprite);
});

// Ethereal ambient
scene.add(new THREE.AmbientLight(0x1a1030, 0.8));
const rim = new THREE.DirectionalLight(0x6644aa, 0.4);
rim.position.set(0, 5, -5);
scene.add(rim);

// Floating motes
const moteGeo = new THREE.BufferGeometry();
const motePos = [];
for (let i = 0; i < 200; i++) motePos.push((Math.random()-0.5)*14, Math.random()*5, (Math.random()-0.5)*8);
moteGeo.setAttribute('position', new THREE.Float32BufferAttribute(motePos, 3));
scene.add(new THREE.Points(moteGeo, new THREE.PointsMaterial({ color: 0x8866cc, size: 0.04, transparent: true, opacity: 0.3 })));

const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  controls.update();

  envGroup.position.y = 2.2 + Math.sin(t * 1.2) * 0.2;
  envGroup.rotation.y = Math.sin(t * 0.6) * 0.2;
  envGroup.position.x = -1.5 + Math.sin(t * 0.25) * 1.8;
  envLight.position.copy(envGroup.position);
  envLight.intensity = 1.5 + Math.sin(t * 1.5) * 0.8;

  zara.userData.screen.emissiveIntensity = 1.2 + Math.sin(t * 1.0) * 0.4;
  kai.userData.screen.emissiveIntensity = 1.2 + Math.sin(t * 1.0 + 1) * 0.4;

  // Isla flickers ethereally
  const flicker = Math.sin(t * 0.15) > 0.92;
  isla.userData.screen.emissive.setHex(flicker ? 0x4390d4 : 0x000000);
  isla.userData.screen.emissiveIntensity = flicker ? 0.5 : 0;

  composer.render();
}
animate();

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
